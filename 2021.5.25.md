### 笔记

1. Vue2.0的生命周期钩子一共有10个:

   - beforCreate:实例初始化完成
   - created:实例化已经完成之后被调用，数据观测，属性和方法的运算，watch/event事件回调已完成，挂载还没还没开始 $el属性上还没有
   - beforeMount:开始挂载之前调用，相关的render函数首次被调用 此时的DOM是数据挂载前的DOM，数据还未挂载
   - mounted:数据已挂载后调用 初始化的el被vm.$el替换，并挂载到实例上去之后的钩子
   - beforeUpdate:数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前
   - updated：在数据驱动下导致的虚拟DOM重新渲染和打补丁之后调用，此时，组件DOM已经更新
   - activated：keep-alive 组件激活时调用 如果你使用keep-alive进行缓存， 又希望每次切换组件的时候更新数据，那么更新数据的请求方式必须写在该钩子函数里
   - deactivated：keep-alive 组件停用时调用
   - beforeDestroy：实例销毁之前调用，此时实例还可用
   - destroyed：实例销毁后调用，实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁

2. 

3. - beforeCreate:刚刚new Vue()之后，这个时候，数据还没有挂载呢，只是一个空壳。

   - created:这个时候已经可以使用到数据，也可以更改数据,在这里更改数据不会触发updated函数；在这里可以在渲染前倒数第二次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取；接下来开始找实例或者组件对应的模板，编译模板为虚拟dom放入到render函数中准备渲染。
   - beforeMount：虚拟dom已经创建完成，马上就要渲染,在这里也可以更改数据，不会触发updated；在这里可以在渲染前最后一次更改数据的机会，不会触发其他的钩子函数，一般可以在这里做初始数据的获取；接下来开始render，渲染出真实dom
   - mounted：此时，组件已经出现在页面中，数据、真实dom都已经处理好了,事件都已经挂载好了；可以在这里操作真实dom等事情...
   - beforeUpdate:重新渲染之前触发，这里不能更改数据，否则会陷入死循环；然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染；
   - updated:数据已经更改完成，dom也重新render完成，这里也不能更改数据
   - beforeDestory:销毁前执行（$destroy方法被调用的时候就会执行）,一般在这里善后:清除计时器、清除非指令绑定的事件等等...
   - destroyed:组件的数据绑定、监听...都去掉了,只剩下dom空壳，这里也可以善后

4. 父组件通过`props`的方式向子组件传递数据，而通过`$emit` 子组件可以向父组件通信。prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。

5. `$emit`绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数。

6. 子实例可以用`this.$parent`访问父实例，子实例被推入父实例的`$children`数组中。通过$parent和$children就可以访问组件的实例，即可以访问此组件的所有方法和data。

7. 边界情况，如在#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组。并且$parent和$children的值不一样，$children 的值是数组，而$parent是个对象。

8. 父组件中通过`provide`来提供变量, 然后在子组件中通过`inject`来注入变量。只要调用了`inject` 那么就可以注入`provide`中的数据，而不局限于只能从当前父组件的props属性中回去数据

9. `ref`：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据。

10. `eventBus` 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。但当项目较大时，就容易造成难以维护的灾难

11. Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化

12. Vuex各个模块：

    - `state`：用于数据的存储，是store中的唯一数据源
    - `getters`：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算
    - `mutations`：类似函数，改变state数据的唯一途径，且不能用于处理异步事件
    - `actions`：类似于`mutation`，用于提交`mutation`来改变状态，而不直接变更状态，可以包含任意异步操作
    - `modules`：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护。

13. 当将纯js对象作为数据对象传递给Vue实例时，Vue会遍历其所有属性，并使用`Object.defineProperty`，将它们转换为 getter/setter。每个组件实例都有一个相应的监视器实例，它将组件呈现期间“触及”的任何属性记录为依赖项。稍后当一个依赖项的 setter 被触发时，它通知观察者，这反过来又导致组件重新呈现。

### 总结

#### 生命周期

Vue2.0的生命周期钩子有10个:

1. - `beforCreate`：实例初始化完成，数据还未挂载。
   - `created`：挂载还未开始，，这里已经可以开始使用数据和更改数据。一般在这里做初始数据的获取。
   - `beforeMount`：数据还未挂载，相关的render函数首次被调用。虚拟dom已经创建完成，在这里也可以更改数据。
   - `mounted`：数据已挂载，可以在这处理真实dom
   - `beforeUpdate`：数据更新时调用，这里不能更改数据，否则会陷入死循环。
   - ``updated`：数据更新已完成，不能更改数据。
   - `activated`,`deactivated`：keep-alive 组件激活/停用时调用
   - `beforeDestory`:销毁前执行,此时实例还可以调用，一般在这里善后:清除计时器、清除非指令绑定的事件等等...
   - `destroyed`:实例销毁后调用,只剩下dom空壳，这里也可以善后



   #### 组件通信

   父子组件通信:

   - `props`：单向数据流，且只读不可被修改。
   -  `$parent` / `$children`：通过此访问组件的实例。`$children` 的值是数组，而`$parent`是个对象。
   - `provide` / `inject` ：只要调用了`inject` 那么就可以注入`provide`中的数据
   -  `ref` 
   -  `$attrs` / `$listeners`

   兄弟组件通信: `eventBus` ; 	vuex

   跨级通信:  `eventBus`；Vuex；`provide` / `inject` 、`$attrs` / `$listeners`
