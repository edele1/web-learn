### 笔记

1. 页面导入样式时，使用link和@import的区别：

   - 从属关系区别。@import 只能导入样式表，link 还可以定义 RSS、rel 连接属性、引入网站图标等；
   - 加载顺序区别；加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载；
   - 兼容性区别；

2. 浏览器内核：

   - IE：Trident，IE 内核；
   - Chrome：以前是 Webkit，现在是 Blink 内核；
   - Firefox：Gecko 内核；
   - Safari：Webkit 内核；
   - Opera：一起是 Presto，现在是 Blink 内核；
   - 360、猎豹浏览器内核：IE + Blink 双内核；
   - 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；
   - 百度浏览器、世界之窗内核：IE 内核；
   - 2345 浏览器：以前是 IE 内核，现在是 IE + Blink 双内核；
   - UC 浏览器内核：Webkit + Trident；

3. 浏览器渲染原理：

   - 首先解析收到的文档，根据文档定义构建一颗 DOM 树，DOM 树是由 DOM 元素及属性节点组成的；
   - 然后对 CSS 进行解析，生成 CSSOM 规则树；
   - 根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。
   - 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
   - 布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。

   为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。

4. 实现浏览器内多个标签页的通信：

   实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者来让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

   - 使用 Websocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端；

   - 可以地调用 localStorage，localStorage 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们可以通过监听 storage 事件，控制它的值来进行页面信息通信；

   - 如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的；

5. 简述前端性能优化：

   **页面内容方面**

   通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况；

   通过 DNS 缓存等机制来减少 DNS 的查询次数；
   通过设置缓存策略，对常用不变的资源进行缓存；
   通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载；
   通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度；

   **服务器方面**
   使用 CDN 服务，来提高用户对于资源请求时的响应速度；
   服务器端自用 Gzip、Deflate 等方式对于传输的资源进行压缩，减少传输文件的体积；
   尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie；

6. BFC及其应用：

   BFC（Block Format Context）块级格式化上下文，是页面盒模型中的一种 `CSS` 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。

   创建 `BFC` 的方式有：

   1. `html` 根元素
   2. `float` 浮动
   3. 绝对定位
   4. `overflow` 不为 `visible`
   5. `display` 为表格布局或者弹性布局；

   `BFC` 主要的作用是：

   1. 清除浮动
   2. 防止同一 `BFC` 容器中的相邻元素间的外边距重叠问题

7. Array数组：

   **属性：**

   - `Array.length`:`Array` 构造函数的 length 属性，其值为1（注意该属性为静态属性，不是数组实例的 length 属性）。
   - `get Array[@@species]`:返回 `Array` 构造函数
   - `Array.prototype`:通过数组的原型对象可以为所有数组对象添加属性。

   方法：

   - `Array.from()`:从类数组对象或者可迭代对象中创建一个新的数组实例。
   - `Array.isArray()`:用来判断某个变量是否是一个数组对象。
   - `Array.of()`:根据一组参数来创建新的数组实例，支持任意的参数数量和类型。

8. 扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

9. 在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”

10. 变量一定要在声明之后使用

11. `let`、`const`语句不出现变量提升

12. 用`Object.freee`方法将对象冻结

### 总结

#### HTML&CSS

1. 浏览器渲染原理：

   解析文档，构建DOM树  →  解析CSS，生成CSSDOM树  →  根据 DOM 树和 CSSOM 规则树构建 Render Tree，渲染对象（渲染树的结点）和 DOM 对象相对应，但是不可见的 DOM 元素不会被插入渲染树。→  浏览器生成渲染树以后，就会根据渲染树来进行布局。→  绘制阶段。

2. 浏览器标签页之间不能直接通信，若要实现多个标签页之间的通信，需要找一个中介者，标签页和中介者进行通信，然后中介者进行消息转发。可以：

   - 使用Websocket。
   - 调用 localStorage。
   - postMessage 方法（获得对应标签页的引用时）

3. 前端性能优化可以从页面内容和服务器两方面入手。

   - 页面内容上优化：减少HTTP请求数；设置缓存策略；DNS缓存机制；延迟加载；预加载。

   - 服务器方面：使用CDN服务，提高资源请求时相应速度；减少传输文件体积；减少cookie大小。

#### JS

1. 扩展运算符（`...`），将数组转为用逗号分隔的参数序列，该运算符主要用于函数调用。
2. “暂时性死区”：在ES6代码块中，`let`命令声明变量之前，该变量都是不可用的。
3. `let`、``const`语句不出现变量提升,`var`语句会出现变量提升。
4. `Object.freee`方法可将对象冻结，对象将不可修改。